\chapter{Reading Files}
\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c}{}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c}\index{Reading Files@{Reading Files}}
\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md653}%
\Hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md653}%
\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md654}{}\doxysection{\texorpdfstring{Security}{Security}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md654}
XML-\/based formats such as Office\+Open XML, Excel2003 XML, OASIS and Gnumeric are susceptible to XML External Entity Processing (XXE) injection attacks when reading spreadsheet files. This can lead to\+:


\begin{DoxyItemize}
\item Disclosure whether a file is existent
\item Server Side Request Forgery
\item Command Execution (depending on the installed PHP wrappers)
\end{DoxyItemize}

To prevent this, by default every XML-\/based Reader looks for XML entities declared inside the DOCTYPE and if any is found an exception is raised.

Read more \href{https://websec.io/2012/08/27/Preventing-XXE-in-PHP.html}{\texttt{ about of XXE injection}}.\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md655}{}\doxysection{\texorpdfstring{Loading a Spreadsheet File}{Loading a Spreadsheet File}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md655}
The simplest way to load a workbook file is to let Php\+Spreadsheet\textquotesingle{}s IO Factory identify the file type and load it, calling the static {\ttfamily load()} method of the {\ttfamily \textbackslash{}Php\+Office\textbackslash{}Php\+Spreadsheet\textbackslash{}IOFactory} class.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$inputFileName\ =\ './sampleData/example1.xls';}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ Load\ \$inputFileName\ to\ a\ Spreadsheet\ Object\ \ **/}
\DoxyCodeLine{\$spreadsheet\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::load(\$inputFileName);}

\end{DoxyCode}


See {\ttfamily \doxylink{01___simple__file__reader__using___i_o_factory_8php}{samples/\+Reader/01\+\_\+\+Simple\+\_\+file\+\_\+reader\+\_\+using\+\_\+\+IOFactory.\+php}} for a working example of this code.

The {\ttfamily load()} method will attempt to identify the file type, and instantiate a loader for that file type; using it to load the file and store the data and any formatting in a {\ttfamily Spreadsheet} object.

The method makes an initial guess at the loader to instantiate based on the file extension; but will test the file before actually executing the load\+: so if (for example) the file is actually a CSV file or contains HTML markup, but that has been given a .xls extension (quite a common practise), it will reject the Xls loader that it would normally use for a .xls file; and test the file using the other loaders until it finds the appropriate loader, and then use that to read the file.

While easy to implement in your code, and you don\textquotesingle{}t need to worry about the file type; this isn\textquotesingle{}t the most efficient method to load a file; and it lacks the flexibility to configure the loader in any way before actually reading the file into a {\ttfamily Spreadsheet} object.\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md656}{}\doxysection{\texorpdfstring{Creating a Reader and Loading a Spreadsheet File}{Creating a Reader and Loading a Spreadsheet File}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md656}
If you know the file type of the spreadsheet file that you need to load, you can instantiate a new reader object for that file type, then use the reader\textquotesingle{}s {\ttfamily load()} method to read the file to a {\ttfamily Spreadsheet} object. It is possible to instantiate the reader objects for each of the different supported filetype by name. However, you may get unpredictable results if the file isn\textquotesingle{}t of the right type (e.\+g. it is a CSV with an extension of .xls), although this type of exception should normally be trapped.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$inputFileName\ =\ './sampleData/example1.xls';}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ Create\ a\ new\ Xls\ Reader\ \ **/}
\DoxyCodeLine{\$reader\ =\ new\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Reader\(\backslash\)Xls();}
\DoxyCodeLine{//\ \ \ \ \$reader\ =\ new\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Reader\(\backslash\)Xlsx();}
\DoxyCodeLine{//\ \ \ \ \$reader\ =\ new\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Reader\(\backslash\)Xml();}
\DoxyCodeLine{//\ \ \ \ \$reader\ =\ new\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Reader\(\backslash\)Ods();}
\DoxyCodeLine{//\ \ \ \ \$reader\ =\ new\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Reader\(\backslash\)Slk();}
\DoxyCodeLine{//\ \ \ \ \$reader\ =\ new\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Reader\(\backslash\)Gnumeric();}
\DoxyCodeLine{//\ \ \ \ \$reader\ =\ new\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Reader\(\backslash\)Csv();}
\DoxyCodeLine{/**\ Load\ \$inputFileName\ to\ a\ Spreadsheet\ Object\ \ **/}
\DoxyCodeLine{\$spreadsheet\ =\ \$reader-\/>load(\$inputFileName);}

\end{DoxyCode}


See {\ttfamily \doxylink{02___simple__file__reader__using__a__specified__reader_8php}{samples/\+Reader/02\+\_\+\+Simple\+\_\+file\+\_\+reader\+\_\+using\+\_\+a\+\_\+specified\+\_\+reader.\+php}} for a working example of this code.

Alternatively, you can use the IO Factory\textquotesingle{}s {\ttfamily create\+Reader()} method to instantiate the reader object for you, simply telling it the file type of the reader that you want instantiating.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$inputFileType\ =\ 'Xls';}
\DoxyCodeLine{//\ \ \ \ \$inputFileType\ =\ 'Xlsx';}
\DoxyCodeLine{//\ \ \ \ \$inputFileType\ =\ 'Xml';}
\DoxyCodeLine{//\ \ \ \ \$inputFileType\ =\ 'Ods';}
\DoxyCodeLine{//\ \ \ \ \$inputFileType\ =\ 'Slk';}
\DoxyCodeLine{//\ \ \ \ \$inputFileType\ =\ 'Gnumeric';}
\DoxyCodeLine{//\ \ \ \ \$inputFileType\ =\ 'Csv';}
\DoxyCodeLine{\$inputFileName\ =\ './sampleData/example1.xls';}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Create\ a\ new\ Reader\ of\ the\ type\ defined\ in\ \$inputFileType\ \ **/}
\DoxyCodeLine{\$reader\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::createReader(\$inputFileType);}
\DoxyCodeLine{/**\ \ Load\ \$inputFileName\ to\ a\ Spreadsheet\ Object\ \ **/}
\DoxyCodeLine{\$spreadsheet\ =\ \$reader-\/>load(\$inputFileName);}

\end{DoxyCode}


See {\ttfamily \doxylink{03___simple__file__reader__using__the___i_o_factory__to__return__a__reader_8php}{samples/\+Reader/03\+\_\+\+Simple\+\_\+file\+\_\+reader\+\_\+using\+\_\+the\+\_\+\+IOFactory\+\_\+to\+\_\+return\+\_\+a\+\_\+reader.\+php}} for a working example of this code.

If you\textquotesingle{}re uncertain of the filetype, you can use the {\ttfamily IOFactory\+::identify()} method to identify the reader that you need, before using the {\ttfamily create\+Reader()} method to instantiate the reader object.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$inputFileName\ =\ './sampleData/example1.xls';}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Identify\ the\ type\ of\ \$inputFileName\ \ **/}
\DoxyCodeLine{\$inputFileType\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::identify(\$inputFileName);}
\DoxyCodeLine{/**\ \ Create\ a\ new\ Reader\ of\ the\ type\ that\ has\ been\ identified\ \ **/}
\DoxyCodeLine{\$reader\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::createReader(\$inputFileType);}
\DoxyCodeLine{/**\ \ Load\ \$inputFileName\ to\ a\ Spreadsheet\ Object\ \ **/}
\DoxyCodeLine{\$spreadsheet\ =\ \$reader-\/>load(\$inputFileName);}

\end{DoxyCode}


See {\ttfamily \doxylink{04___simple__file__reader__using__the___i_o_factory__to__identify__a__reader__to__use_8php}{samples/\+Reader/04\+\_\+\+Simple\+\_\+file\+\_\+reader\+\_\+using\+\_\+the\+\_\+\+IOFactory\+\_\+to\+\_\+identify\+\_\+a\+\_\+reader\+\_\+to\+\_\+use.\+php}} for a working example of this code.\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md657}{}\doxysection{\texorpdfstring{Spreadsheet Reader Options}{Spreadsheet Reader Options}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md657}
Once you have created a reader object for the workbook that you want to load, you have the opportunity to set additional options before executing the {\ttfamily load()} method.\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md658}{}\doxysubsection{\texorpdfstring{Reading Only Data from a Spreadsheet File}{Reading Only Data from a Spreadsheet File}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md658}
If you\textquotesingle{}re only interested in the cell values in a workbook, but don\textquotesingle{}t need any of the cell formatting information, then you can set the reader to read only the data values and any formulae from each cell using the {\ttfamily set\+Read\+Data\+Only()} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$inputFileType\ =\ 'Xls';}
\DoxyCodeLine{\$inputFileName\ =\ './sampleData/example1.xls';}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Create\ a\ new\ Reader\ of\ the\ type\ defined\ in\ \$inputFileType\ \ **/}
\DoxyCodeLine{\$reader\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::createReader(\$inputFileType);}
\DoxyCodeLine{/**\ \ Advise\ the\ Reader\ that\ we\ only\ want\ to\ load\ cell\ data\ \ **/}
\DoxyCodeLine{\$reader-\/>setReadDataOnly(true);}
\DoxyCodeLine{/**\ \ Load\ \$inputFileName\ to\ a\ Spreadsheet\ Object\ \ **/}
\DoxyCodeLine{\$spreadsheet\ =\ \$reader-\/>load(\$inputFileName);}

\end{DoxyCode}


See {\ttfamily \doxylink{05___simple__file__reader__using__the__read__data__only__option_8php}{samples/\+Reader/05\+\_\+\+Simple\+\_\+file\+\_\+reader\+\_\+using\+\_\+the\+\_\+read\+\_\+data\+\_\+only\+\_\+option.\+php}} for a working example of this code.

It is important to note that Workbooks (and Php\+Spreadsheet) store dates and times as simple numeric values\+: they can only be distinguished from other numeric values by the format mask that is applied to that cell. When setting read data only to true, Php\+Spreadsheet doesn\textquotesingle{}t read the cell format masks, so it is not possible to differentiate between dates/times and numbers.

The Gnumeric loader has been written to read the format masks for date values even when read data only has been set to true, so it can differentiate between dates/times and numbers; but this change hasn\textquotesingle{}t yet been implemented for the other readers.

Reading Only Data from a Spreadsheet File applies to Readers\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{6}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N    }\\\cline{1-6}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N    }\\\cline{1-6}
\endhead
Xlsx   &\PBS\centering YES   &Xls   &\PBS\centering YES   &Xml   &\PBS\centering YES    \\\cline{1-6}
Ods   &\PBS\centering YES   &SYLK   &\PBS\centering NO   &Gnumeric   &\PBS\centering YES   \\\cline{1-6}
\end{longtabu}
CSV \texorpdfstring{$\vert$}{|} NO \texorpdfstring{$\vert$}{|} HTML \texorpdfstring{$\vert$}{|} NO\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md659}{}\doxysubsection{\texorpdfstring{Reading Only Named Work\+Sheets from a File}{Reading Only Named Work\+Sheets from a File}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md659}
If your workbook contains a number of worksheets, but you are only interested in reading some of those, then you can use the {\ttfamily set\+Load\+Sheets\+Only()} method to identify those sheets you are interested in reading.

To read a single sheet, you can pass that sheet name as a parameter to the {\ttfamily set\+Load\+Sheets\+Only()} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$inputFileType\ =\ 'Xls';}
\DoxyCodeLine{\$inputFileName\ =\ './sampleData/example1.xls';}
\DoxyCodeLine{\$sheetname\ =\ 'Data\ Sheet\ \#2';}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Create\ a\ new\ Reader\ of\ the\ type\ defined\ in\ \$inputFileType\ \ **/}
\DoxyCodeLine{\$reader\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::createReader(\$inputFileType);}
\DoxyCodeLine{/**\ \ Advise\ the\ Reader\ of\ which\ WorkSheets\ we\ want\ to\ load\ \ **/}
\DoxyCodeLine{\$reader-\/>setLoadSheetsOnly(\$sheetname);}
\DoxyCodeLine{/**\ \ Load\ \$inputFileName\ to\ a\ Spreadsheet\ Object\ \ **/}
\DoxyCodeLine{\$spreadsheet\ =\ \$reader-\/>load(\$inputFileName);}

\end{DoxyCode}


See {\ttfamily \doxylink{07___simple__file__reader__loading__a__single__named__worksheet_8php}{samples/\+Reader/07\+\_\+\+Simple\+\_\+file\+\_\+reader\+\_\+loading\+\_\+a\+\_\+single\+\_\+named\+\_\+worksheet.\+php}} for a working example of this code.

If you want to read more than just a single sheet, you can pass a list of sheet names as an array parameter to the {\ttfamily set\+Load\+Sheets\+Only()} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$inputFileType\ =\ 'Xls';}
\DoxyCodeLine{\$inputFileName\ =\ './sampleData/example1.xls';}
\DoxyCodeLine{\$sheetnames\ =\ ['Data\ Sheet\ \#1','Data\ Sheet\ \#3'];}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Create\ a\ new\ Reader\ of\ the\ type\ defined\ in\ \$inputFileType\ \ **/}
\DoxyCodeLine{\$reader\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::createReader(\$inputFileType);}
\DoxyCodeLine{/**\ \ Advise\ the\ Reader\ of\ which\ WorkSheets\ we\ want\ to\ load\ \ **/}
\DoxyCodeLine{\$reader-\/>setLoadSheetsOnly(\$sheetnames);}
\DoxyCodeLine{/**\ \ Load\ \$inputFileName\ to\ a\ Spreadsheet\ Object\ \ **/}
\DoxyCodeLine{\$spreadsheet\ =\ \$reader-\/>load(\$inputFileName);}

\end{DoxyCode}


See {\ttfamily \doxylink{08___simple__file__reader__loading__several__named__worksheets_8php}{samples/\+Reader/08\+\_\+\+Simple\+\_\+file\+\_\+reader\+\_\+loading\+\_\+several\+\_\+named\+\_\+worksheets.\+php}} for a working example of this code.

To reset this option to the default, you can call the {\ttfamily set\+Load\+All\+Sheets()} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$inputFileType\ =\ 'Xls';}
\DoxyCodeLine{\$inputFileName\ =\ './sampleData/example1.xls';}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Create\ a\ new\ Reader\ of\ the\ type\ defined\ in\ \$inputFileType\ \ **/}
\DoxyCodeLine{\$reader\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::createReader(\$inputFileType);}
\DoxyCodeLine{/**\ \ Advise\ the\ Reader\ to\ load\ all\ Worksheets\ \ **/}
\DoxyCodeLine{\$reader-\/>setLoadAllSheets();}
\DoxyCodeLine{/**\ \ Load\ \$inputFileName\ to\ a\ Spreadsheet\ Object\ \ **/}
\DoxyCodeLine{\$spreadsheet\ =\ \$reader-\/>load(\$inputFileName);}

\end{DoxyCode}


See {\ttfamily \doxylink{06___simple__file__reader__loading__all__worksheets_8php}{samples/\+Reader/06\+\_\+\+Simple\+\_\+file\+\_\+reader\+\_\+loading\+\_\+all\+\_\+worksheets.\+php}} for a working example of this code.

Reading Only Named Work\+Sheets from a File applies to Readers\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{6}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N    }\\\cline{1-6}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N    }\\\cline{1-6}
\endhead
Xlsx   &\PBS\centering YES   &Xls   &\PBS\centering YES   &Xml   &\PBS\centering YES    \\\cline{1-6}
Ods   &\PBS\centering YES   &SYLK   &\PBS\centering NO   &Gnumeric   &\PBS\centering YES   \\\cline{1-6}
\end{longtabu}
CSV \texorpdfstring{$\vert$}{|} NO \texorpdfstring{$\vert$}{|} HTML \texorpdfstring{$\vert$}{|} NO\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md660}{}\doxysubsection{\texorpdfstring{Reading Only Specific Columns and Rows from a File (Read Filters)}{Reading Only Specific Columns and Rows from a File (Read Filters)}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md660}
If you are only interested in reading part of a worksheet, then you can write a filter class that identifies whether or not individual cells should be read by the loader. A read filter must implement the {\ttfamily \textbackslash{}Php\+Office\textbackslash{}Php\+Spreadsheet\textbackslash{}Reader\textbackslash{}IRead\+Filter} interface, and contain a {\ttfamily read\+Cell()} method that accepts arguments of {\ttfamily \$column}, {\ttfamily \$row} and {\ttfamily \$worksheet\+Name}, and return a boolean true or false that indicates whether a workbook cell identified by those arguments should be read or not.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$inputFileType\ =\ 'Xls';}
\DoxyCodeLine{\$inputFileName\ =\ './sampleData/example1.xls';}
\DoxyCodeLine{\$sheetname\ =\ 'Data\ Sheet\ \#3';}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Define\ a\ Read\ Filter\ class\ implementing\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Reader\(\backslash\)IReadFilter\ \ */}
\DoxyCodeLine{class\ MyReadFilter\ implements\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Reader\(\backslash\)IReadFilter}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ public\ function\ readCell(\$column,\ \$row,\ \$worksheetName\ =\ '')\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ \ Read\ rows\ 1\ to\ 7\ and\ columns\ A\ to\ E\ only}
\DoxyCodeLine{\ \ \ \ \ \ \ \ if\ (\$row\ >=\ 1\ \&\&\ \$row\ <=\ 7)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ if\ (in\_array(\$column,range('A','E')))\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ true;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ false;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Create\ an\ Instance\ of\ our\ Read\ Filter\ \ **/}
\DoxyCodeLine{\$filterSubset\ =\ new\ MyReadFilter();}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Create\ a\ new\ Reader\ of\ the\ type\ defined\ in\ \$inputFileType\ \ **/}
\DoxyCodeLine{\$reader\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::createReader(\$inputFileType);}
\DoxyCodeLine{/**\ \ Tell\ the\ Reader\ that\ we\ want\ to\ use\ the\ Read\ Filter\ \ **/}
\DoxyCodeLine{\$reader-\/>setReadFilter(\$filterSubset);}
\DoxyCodeLine{/**\ \ Load\ only\ the\ rows\ and\ columns\ that\ match\ our\ filter\ to\ Spreadsheet\ \ **/}
\DoxyCodeLine{\$spreadsheet\ =\ \$reader-\/>load(\$inputFileName);}

\end{DoxyCode}


See {\ttfamily \doxylink{09___simple__file__reader__using__a__read__filter_8php}{samples/\+Reader/09\+\_\+\+Simple\+\_\+file\+\_\+reader\+\_\+using\+\_\+a\+\_\+read\+\_\+filter.\+php}} for a working example of this code.

This example is not particularly useful, because it can only be used in a very specific circumstance (when you only want cells in the range A1\+:E7 from your worksheet. A generic Read Filter would probably be more useful\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{/**\ \ Define\ a\ Read\ Filter\ class\ implementing\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Reader\(\backslash\)IReadFilter\ \ */}
\DoxyCodeLine{class\ MyReadFilter\ implements\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Reader\(\backslash\)IReadFilter}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ private\ \$startRow\ =\ 0;}
\DoxyCodeLine{\ \ \ \ private\ \$endRow\ \ \ =\ 0;}
\DoxyCodeLine{\ \ \ \ private\ \$columns\ \ =\ [];}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ /**\ \ Get\ the\ list\ of\ rows\ and\ columns\ to\ read\ \ */}
\DoxyCodeLine{\ \ \ \ public\ function\ \_\_construct(\$startRow,\ \$endRow,\ \$columns)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \$this-\/>startRow\ =\ \$startRow;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \$this-\/>endRow\ \ \ =\ \$endRow;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \$this-\/>columns\ \ =\ \$columns;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ public\ function\ readCell(\$column,\ \$row,\ \$worksheetName\ =\ '')\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ \ Only\ read\ the\ rows\ and\ columns\ that\ were\ configured}
\DoxyCodeLine{\ \ \ \ \ \ \ \ if\ (\$row\ >=\ \$this-\/>startRow\ \&\&\ \$row\ <=\ \$this-\/>endRow)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ if\ (in\_array(\$column,\$this-\/>columns))\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ true;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ false;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Create\ an\ Instance\ of\ our\ Read\ Filter,\ passing\ in\ the\ cell\ range\ \ **/}
\DoxyCodeLine{\$filterSubset\ =\ new\ MyReadFilter(9,15,range('G','K'));}

\end{DoxyCode}


See {\ttfamily \doxylink{10___simple__file__reader__using__a__configurable__read__filter_8php}{samples/\+Reader/10\+\_\+\+Simple\+\_\+file\+\_\+reader\+\_\+using\+\_\+a\+\_\+configurable\+\_\+read\+\_\+filter.\+php}} for a working example of this code.

This can be particularly useful for conserving memory, by allowing you to read and process a large workbook in "{}chunks"{}\+: an example of this usage might be when transferring data from an Excel worksheet to a database.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$inputFileType\ =\ 'Xls';}
\DoxyCodeLine{\$inputFileName\ =\ './sampleData/example2.xls';}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Define\ a\ Read\ Filter\ class\ implementing\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Reader\(\backslash\)IReadFilter\ \ */}
\DoxyCodeLine{class\ ChunkReadFilter\ implements\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Reader\(\backslash\)IReadFilter}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ private\ \$startRow\ =\ 0;}
\DoxyCodeLine{\ \ \ \ private\ \$endRow\ \ \ =\ 0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ /**\ \ Set\ the\ list\ of\ rows\ that\ we\ want\ to\ read\ \ */}
\DoxyCodeLine{\ \ \ \ public\ function\ setRows(\$startRow,\ \$chunkSize)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \$this-\/>startRow\ =\ \$startRow;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \$this-\/>endRow\ \ \ =\ \$startRow\ +\ \$chunkSize;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ public\ function\ readCell(\$column,\ \$row,\ \$worksheetName\ =\ '')\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ \ Only\ read\ the\ heading\ row,\ and\ the\ configured\ rows}
\DoxyCodeLine{\ \ \ \ \ \ \ \ if\ ((\$row\ ==\ 1)\ ||\ (\$row\ >=\ \$this-\/>startRow\ \&\&\ \$row\ <\ \$this-\/>endRow))\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ return\ true;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ false;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Create\ a\ new\ Reader\ of\ the\ type\ defined\ in\ \$inputFileType\ \ **/}
\DoxyCodeLine{\$reader\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::createReader(\$inputFileType);}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Define\ how\ many\ rows\ we\ want\ to\ read\ for\ each\ "{}chunk"{}\ \ **/}
\DoxyCodeLine{\$chunkSize\ =\ 2048;}
\DoxyCodeLine{/**\ \ Create\ a\ new\ Instance\ of\ our\ Read\ Filter\ \ **/}
\DoxyCodeLine{\$chunkFilter\ =\ new\ ChunkReadFilter();}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Tell\ the\ Reader\ that\ we\ want\ to\ use\ the\ Read\ Filter\ \ **/}
\DoxyCodeLine{\$reader-\/>setReadFilter(\$chunkFilter);}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Loop\ to\ read\ our\ worksheet\ in\ "{}chunk\ size"{}\ blocks\ \ **/}
\DoxyCodeLine{for\ (\$startRow\ =\ 2;\ \$startRow\ <=\ 65536;\ \$startRow\ +=\ \$chunkSize)\ \{}
\DoxyCodeLine{\ \ \ \ /**\ \ Tell\ the\ Read\ Filter\ which\ rows\ we\ want\ this\ iteration\ \ **/}
\DoxyCodeLine{\ \ \ \ \$chunkFilter-\/>setRows(\$startRow,\$chunkSize);}
\DoxyCodeLine{\ \ \ \ /**\ \ Load\ only\ the\ rows\ that\ match\ our\ filter\ \ **/}
\DoxyCodeLine{\ \ \ \ \$spreadsheet\ =\ \$reader-\/>load(\$inputFileName);}
\DoxyCodeLine{\ \ \ \ //\ \ \ \ Do\ some\ processing\ here}
\DoxyCodeLine{\}}

\end{DoxyCode}


See {\ttfamily samples/\+Reader/12\+\_\+\+Reading\+\_\+a\+\_\+workbook\+\_\+in\+\_\+chunks\+\_\+using\+\_\+a\+\_\+configurable\+\_\+read\+\_\+filter\+\_\+} for a working example of this code.

Using Read Filters applies to\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{6}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N    }\\\cline{1-6}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N    }\\\cline{1-6}
\endhead
Xlsx   &\PBS\centering YES   &Xls   &\PBS\centering YES   &Xml   &\PBS\centering YES    \\\cline{1-6}
Ods   &\PBS\centering YES   &SYLK   &\PBS\centering NO   &Gnumeric   &\PBS\centering YES    \\\cline{1-6}
CSV   &\PBS\centering YES   &HTML   &\PBS\centering NO   &&\PBS\centering \\\cline{1-6}
\end{longtabu}
\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md661}{}\doxysubsection{\texorpdfstring{Combining Multiple Files into a Single Spreadsheet Object}{Combining Multiple Files into a Single Spreadsheet Object}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md661}
While you can limit the number of worksheets that are read from a workbook file using the {\ttfamily set\+Load\+Sheets\+Only()} method, certain readers also allow you to combine several individual "{}sheets"{} from different files into a single {\ttfamily Spreadsheet} object, where each individual file is a single worksheet within that workbook. For each file that you read, you need to indicate which worksheet index it should be loaded into using the {\ttfamily set\+Sheet\+Index()} method of the {\ttfamily \$reader}, then use the {\ttfamily load\+Into\+Existing()} method rather than the {\ttfamily load()} method to actually read the file into that worksheet.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$inputFileType\ =\ 'Csv';}
\DoxyCodeLine{\$inputFileNames\ =\ [}
\DoxyCodeLine{\ \ \ \ './sampleData/example1.csv',}
\DoxyCodeLine{\ \ \ \ './sampleData/example2.csv'}
\DoxyCodeLine{\ \ \ \ './sampleData/example3.csv'}
\DoxyCodeLine{];}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Create\ a\ new\ Reader\ of\ the\ type\ defined\ in\ \$inputFileType\ \ **/}
\DoxyCodeLine{\$reader\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::createReader(\$inputFileType);}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Extract\ the\ first\ named\ file\ from\ the\ array\ list\ \ **/}
\DoxyCodeLine{\$inputFileName\ =\ array\_shift(\$inputFileNames);}
\DoxyCodeLine{/**\ \ Load\ the\ initial\ file\ to\ the\ first\ worksheet\ in\ a\ \`{}Spreadsheet`\ Object\ \ **/}
\DoxyCodeLine{\$spreadsheet\ =\ \$reader-\/>load(\$inputFileName);}
\DoxyCodeLine{/**\ \ Set\ the\ worksheet\ title\ (to\ the\ filename\ that\ we've\ loaded)\ \ **/}
\DoxyCodeLine{\$spreadsheet-\/>getActiveSheet()}
\DoxyCodeLine{\ \ \ \ -\/>setTitle(pathinfo(\$inputFileName,PATHINFO\_BASENAME));}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Loop\ through\ all\ the\ remaining\ files\ in\ the\ list\ \ **/}
\DoxyCodeLine{foreach(\$inputFileNames\ as\ \$sheet\ =>\ \$inputFileName)\ \{}
\DoxyCodeLine{\ \ \ \ /**\ \ Increment\ the\ worksheet\ index\ pointer\ for\ the\ Reader\ \ **/}
\DoxyCodeLine{\ \ \ \ \$reader-\/>setSheetIndex(\$sheet+1);}
\DoxyCodeLine{\ \ \ \ /**\ \ Load\ the\ current\ file\ into\ a\ new\ worksheet\ in\ Spreadsheet\ \ **/}
\DoxyCodeLine{\ \ \ \ \$reader-\/>loadIntoExisting(\$inputFileName,\$spreadsheet);}
\DoxyCodeLine{\ \ \ \ /**\ \ Set\ the\ worksheet\ title\ (to\ the\ filename\ that\ we've\ loaded)\ \ **/}
\DoxyCodeLine{\ \ \ \ \$spreadsheet-\/>getActiveSheet()}
\DoxyCodeLine{\ \ \ \ \ \ \ \ -\/>setTitle(pathinfo(\$inputFileName,PATHINFO\_BASENAME));}
\DoxyCodeLine{\}}

\end{DoxyCode}


See {\ttfamily \doxylink{13___simple__file__reader__for__multiple___c_s_v__files_8php}{samples/\+Reader/13\+\_\+\+Simple\+\_\+file\+\_\+reader\+\_\+for\+\_\+multiple\+\_\+\+CSV\+\_\+files.\+php}} for a working example of this code.

Note that using the same sheet index for multiple sheets won\textquotesingle{}t append files into the same sheet, but overwrite the results of the previous load. You cannot load multiple CSV files into the same worksheet.

Combining Multiple Files into a Single Spreadsheet Object applies to\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{6}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N    }\\\cline{1-6}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N    }\\\cline{1-6}
\endhead
Xlsx   &\PBS\centering NO   &Xls   &\PBS\centering NO   &Xml   &\PBS\centering NO    \\\cline{1-6}
Ods   &\PBS\centering NO   &SYLK   &\PBS\centering YES   &Gnumeric   &\PBS\centering NO   \\\cline{1-6}
\end{longtabu}
CSV \texorpdfstring{$\vert$}{|} YES \texorpdfstring{$\vert$}{|} HTML \texorpdfstring{$\vert$}{|} NO\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md662}{}\doxysubsection{\texorpdfstring{Combining Read Filters with the {\ttfamily set\+Sheet\+Index()} method to split a large CSV file across multiple Worksheets}{Combining Read Filters with the {\ttfamily set\+Sheet\+Index()} method to split a large CSV file across multiple Worksheets}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md662}
An Xls BIFF .xls file is limited to 65536 rows in a worksheet, while the Xlsx Microsoft Office Open XML Spreadsheet\+ML .xlsx file is limited to 1,048,576 rows in a worksheet; but a CSV file is not limited other than by available disk space. This means that we wouldn’t ordinarily be able to read all the rows from a very large CSV file that exceeded those limits, and save it as an Xls or Xlsx file. However, by using Read Filters to read the CSV file in "{}chunks"{} (using the Chunk\+Read\+Filter Class that we defined in the above section, and the {\ttfamily set\+Sheet\+Index()} method of the {\ttfamily \$reader}, we can split the CSV file across several individual worksheets.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$inputFileType\ =\ 'Csv';}
\DoxyCodeLine{\$inputFileName\ =\ './sampleData/example2.csv';}
\DoxyCodeLine{}
\DoxyCodeLine{echo\ 'Loading\ file\ ',pathinfo(\$inputFileName,PATHINFO\_BASENAME),'\ using\ IOFactory\ with\ a\ defined\ reader\ type\ of\ ',\$inputFileType,'<br\ />';}
\DoxyCodeLine{/**\ \ Create\ a\ new\ Reader\ of\ the\ type\ defined\ in\ \$inputFileType\ \ **/}
\DoxyCodeLine{\$reader\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::createReader(\$inputFileType);}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Define\ how\ many\ rows\ we\ want\ to\ read\ for\ each\ "{}chunk"{}\ \ **/}
\DoxyCodeLine{\$chunkSize\ =\ 65530;}
\DoxyCodeLine{/**\ \ Create\ a\ new\ Instance\ of\ our\ Read\ Filter\ \ **/}
\DoxyCodeLine{\$chunkFilter\ =\ new\ ChunkReadFilter();}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Tell\ the\ Reader\ that\ we\ want\ to\ use\ the\ Read\ Filter\ \ **/}
\DoxyCodeLine{/**\ \ \ \ and\ that\ we\ want\ to\ store\ it\ in\ contiguous\ rows/columns\ \ **/}
\DoxyCodeLine{}
\DoxyCodeLine{\$reader-\/>setReadFilter(\$chunkFilter)}
\DoxyCodeLine{\ \ \ \ -\/>setContiguous(true);}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Instantiate\ a\ new\ Spreadsheet\ object\ manually\ \ **/}
\DoxyCodeLine{\$spreadsheet\ =\ new\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Spreadsheet();}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Set\ a\ sheet\ index\ \ **/}
\DoxyCodeLine{\$sheet\ =\ 0;}
\DoxyCodeLine{/**\ \ Loop\ to\ read\ our\ worksheet\ in\ "{}chunk\ size"{}\ blocks\ \ **/}
\DoxyCodeLine{/**\ \ \$startRow\ is\ set\ to\ 2\ initially\ because\ we\ always\ read\ the\ headings\ in\ row\ \#1\ \ **/}
\DoxyCodeLine{for\ (\$startRow\ =\ 2;\ \$startRow\ <=\ 1000000;\ \$startRow\ +=\ \$chunkSize)\ \{}
\DoxyCodeLine{\ \ \ \ /**\ \ Tell\ the\ Read\ Filter\ which\ rows\ we\ want\ to\ read\ this\ loop\ \ **/}
\DoxyCodeLine{\ \ \ \ \$chunkFilter-\/>setRows(\$startRow,\$chunkSize);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ /**\ \ Increment\ the\ worksheet\ index\ pointer\ for\ the\ Reader\ \ **/}
\DoxyCodeLine{\ \ \ \ \$reader-\/>setSheetIndex(\$sheet);}
\DoxyCodeLine{\ \ \ \ /**\ \ Load\ only\ the\ rows\ that\ match\ our\ filter\ into\ a\ new\ worksheet\ \ **/}
\DoxyCodeLine{\ \ \ \ \$reader-\/>loadIntoExisting(\$inputFileName,\$spreadsheet);}
\DoxyCodeLine{\ \ \ \ /**\ \ Set\ the\ worksheet\ title\ for\ the\ sheet\ that\ we've\ justloaded)\ \ **/}
\DoxyCodeLine{\ \ \ \ /**\ \ \ \ and\ increment\ the\ sheet\ index\ as\ well\ \ **/}
\DoxyCodeLine{\ \ \ \ \$spreadsheet-\/>getActiveSheet()-\/>setTitle('Country\ Data\ \#'.(++\$sheet));}
\DoxyCodeLine{\}}

\end{DoxyCode}


See {\ttfamily \doxylink{14___reading__a__large___c_s_v__file__in__chunks__to__split__across__multiple__worksheets_8php}{samples/\+Reader/14\+\_\+\+Reading\+\_\+a\+\_\+large\+\_\+\+CSV\+\_\+file\+\_\+in\+\_\+chunks\+\_\+to\+\_\+split\+\_\+across\+\_\+multiple\+\_\+worksheets.\+php}} for a working example of this code.

This code will read 65,530 rows at a time from the CSV file that we’re loading, and store each "{}chunk"{} in a new worksheet.

The {\ttfamily set\+Contiguous()} method for the Reader is important here. It is applicable only when working with a Read Filter, and identifies whether or not the cells should be stored by their position within the CSV file, or their position relative to the filter.

For example, if the filter returned true for cells in the range B2\+:C3, then with set\+Contiguous set to false (the default) these would be loaded as B2\+:C3 in the {\ttfamily Spreadsheet} object; but with set\+Contiguous set to true, they would be loaded as A1\+:B2.

Splitting a single loaded file across multiple worksheets applies to\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{6}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N    }\\\cline{1-6}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N    }\\\cline{1-6}
\endhead
Xlsx   &\PBS\centering NO   &Xls   &\PBS\centering NO   &Xml   &\PBS\centering NO    \\\cline{1-6}
Ods   &\PBS\centering NO   &SYLK   &\PBS\centering NO   &Gnumeric   &\PBS\centering NO   \\\cline{1-6}
\end{longtabu}
CSV \texorpdfstring{$\vert$}{|} YES \texorpdfstring{$\vert$}{|} HTML \texorpdfstring{$\vert$}{|} NO\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md663}{}\doxysubsection{\texorpdfstring{Pipe or Tab Separated Value Files}{Pipe or Tab Separated Value Files}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md663}
The CSV loader will attempt to auto-\/detect the separator used in the file. If it cannot auto-\/detect, it will default to the comma. If this does not fit your use-\/case, you can manually specify a separator by using the {\ttfamily set\+Delimiter()} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$inputFileType\ =\ 'Csv';}
\DoxyCodeLine{\$inputFileName\ =\ './sampleData/example1.tsv';}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Create\ a\ new\ Reader\ of\ the\ type\ defined\ in\ \$inputFileType\ \ **/}
\DoxyCodeLine{\$reader\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::createReader(\$inputFileType);}
\DoxyCodeLine{/**\ \ Set\ the\ delimiter\ to\ a\ TAB\ character\ \ **/}
\DoxyCodeLine{\$reader-\/>setDelimiter("{}\(\backslash\)t"{});}
\DoxyCodeLine{//\ \ \ \ \$reader-\/>setDelimiter('|');}
\DoxyCodeLine{}
\DoxyCodeLine{/**\ \ Load\ the\ file\ to\ a\ Spreadsheet\ Object\ \ **/}
\DoxyCodeLine{\$spreadsheet\ =\ \$reader-\/>load(\$inputFileName);}

\end{DoxyCode}


See {\ttfamily \doxylink{15___simple__file__reader__for__tab__separated__value__file__using__the___advanced___value___binder_8php}{samples/\+Reader/15\+\_\+\+Simple\+\_\+file\+\_\+reader\+\_\+for\+\_\+tab\+\_\+separated\+\_\+value\+\_\+file\+\_\+using\+\_\+the\+\_\+\+Advanced\+\_\+\+Value\+\_\+\+Binder.\+php}} for a working example of this code.

In addition to the delimiter, you can also use the following methods to set other attributes for the data load\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Method   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Method   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default    }\\\cline{1-2}
\endhead
set\+Enclosure()   &{\ttfamily "{}}    \\\cline{1-2}
set\+Input\+Encoding()   &{\ttfamily UTF-\/8}   \\\cline{1-2}
\end{longtabu}


Setting CSV delimiter applies to\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{6}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N    }\\\cline{1-6}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N    }\\\cline{1-6}
\endhead
Xlsx   &\PBS\centering NO   &Xls   &\PBS\centering NO   &Xml   &\PBS\centering NO    \\\cline{1-6}
Ods   &\PBS\centering NO   &SYLK   &\PBS\centering NO   &Gnumeric   &\PBS\centering NO   \\\cline{1-6}
\end{longtabu}
CSV \texorpdfstring{$\vert$}{|} YES \texorpdfstring{$\vert$}{|} HTML \texorpdfstring{$\vert$}{|} NO\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md664}{}\doxysubsection{\texorpdfstring{A Brief Word about the Advanced Value Binder}{A Brief Word about the Advanced Value Binder}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md664}
When loading data from a file that contains no formatting information, such as a CSV file, then data is read either as strings or numbers (float or integer). This means that Php\+Spreadsheet does not automatically recognise dates/times (such as {\ttfamily 16-\/Apr-\/2009} or {\ttfamily 13\+:30}), booleans ({\ttfamily true} or {\ttfamily false}), percentages ({\ttfamily 75\%}), hyperlinks ({\ttfamily \href{https://www.example.com}{\texttt{ https\+://www.\+example.\+com}}}), etc as anything other than simple strings. However, you can apply additional processing that is executed against these values during the load process within a Value Binder.

A Value Binder is a class that implement the {\ttfamily \textbackslash{}Php\+Office\textbackslash{}Php\+Spreadsheet\textbackslash{}Cell\textbackslash{}IValue\+Binder} interface. It must contain a {\ttfamily bind\+Value()} method that accepts a {\ttfamily \textbackslash{}Php\+Office\textbackslash{}Php\+Spreadsheet\textbackslash{}Cell\textbackslash{}Cell} and a value as arguments, and return a boolean {\ttfamily true} or {\ttfamily false} that indicates whether the workbook cell has been populated with the value or not. The Advanced Value Binder implements such a class\+: amongst other tests, it identifies a string comprising "{}\+TRUE"{} or "{}\+FALSE"{} (based on locale settings) and sets it to a boolean; or a number in scientific format (e.\+g. "{}1.\+234e-\/5"{}) and converts it to a float; or dates and times, converting them to their Excel timestamp value – before storing the value in the cell object. It also sets formatting for strings that are identified as dates, times or percentages. It could easily be extended to provide additional handling (including text or cell formatting) when it encountered a hyperlink, or HTML markup within a CSV file.

So using a Value Binder allows a great deal more flexibility in the loader logic when reading unformatted text files.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{/**\ \ Tell\ PhpSpreadsheet\ that\ we\ want\ to\ use\ the\ Advanced\ Value\ Binder\ \ **/}
\DoxyCodeLine{\(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Cell\(\backslash\)Cell::setValueBinder(\ new\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Cell\(\backslash\)AdvancedValueBinder()\ );}
\DoxyCodeLine{}
\DoxyCodeLine{\$inputFileType\ =\ 'Csv';}
\DoxyCodeLine{\$inputFileName\ =\ './sampleData/example1.tsv';}
\DoxyCodeLine{}
\DoxyCodeLine{\$reader\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::createReader(\$inputFileType);}
\DoxyCodeLine{\$reader-\/>setDelimiter("{}\(\backslash\)t"{});}
\DoxyCodeLine{\$spreadsheet\ =\ \$reader-\/>load(\$inputFileName);}

\end{DoxyCode}


See {\ttfamily \doxylink{15___simple__file__reader__for__tab__separated__value__file__using__the___advanced___value___binder_8php}{samples/\+Reader/15\+\_\+\+Simple\+\_\+file\+\_\+reader\+\_\+for\+\_\+tab\+\_\+separated\+\_\+value\+\_\+file\+\_\+using\+\_\+the\+\_\+\+Advanced\+\_\+\+Value\+\_\+\+Binder.\+php}} for a working example of this code.

Loading using a Value Binder applies to\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{6}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N    }\\\cline{1-6}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Reader   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Y/N    }\\\cline{1-6}
\endhead
Xlsx   &\PBS\centering NO   &Xls   &\PBS\centering NO   &Xml   &\PBS\centering NO    \\\cline{1-6}
Ods   &\PBS\centering NO   &SYLK   &\PBS\centering NO   &Gnumeric   &\PBS\centering NO   \\\cline{1-6}
\end{longtabu}
CSV \texorpdfstring{$\vert$}{|} YES \texorpdfstring{$\vert$}{|} HTML \texorpdfstring{$\vert$}{|} YES\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md665}{}\doxysection{\texorpdfstring{Error Handling}{Error Handling}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md665}
Of course, you should always apply some error handling to your scripts as well. Php\+Spreadsheet throws exceptions, so you can wrap all your code that accesses the library methods within Try/\+Catch blocks to trap for any problems that are encountered, and deal with them in an appropriate manner.

The Php\+Spreadsheet Readers throw a {\ttfamily \textbackslash{}Php\+Office\textbackslash{}Php\+Spreadsheet\textbackslash{}Reader\textbackslash{}Exception}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$inputFileName\ =\ './sampleData/example-\/1.xls';}
\DoxyCodeLine{}
\DoxyCodeLine{try\ \{}
\DoxyCodeLine{\ \ \ \ /**\ Load\ \$inputFileName\ to\ a\ Spreadsheet\ Object\ \ **/}
\DoxyCodeLine{\ \ \ \ \$spreadsheet\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::load(\$inputFileName);}
\DoxyCodeLine{\}\ catch(\(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)Reader\(\backslash\)Exception\ \$e)\ \{}
\DoxyCodeLine{\ \ \ \ die('Error\ loading\ file:\ '.\$e-\/>getMessage());}
\DoxyCodeLine{\}}

\end{DoxyCode}


See {\ttfamily \doxylink{16___handling__loader__exceptions__using___try_catch_8php}{samples/\+Reader/16\+\_\+\+Handling\+\_\+loader\+\_\+exceptions\+\_\+using\+\_\+\+Try\+Catch.\+php}} for a working example of this code.\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md666}{}\doxysection{\texorpdfstring{Helper Methods}{Helper Methods}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md666}
You can retrieve a list of worksheet names contained in a file without loading the whole file by using the Reader’s {\ttfamily list\+Worksheet\+Names()} method; similarly, a {\ttfamily list\+Worksheet\+Info()} method will retrieve the dimensions of worksheet in a file without needing to load and parse the whole file.\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md667}{}\doxysubsection{\texorpdfstring{list\+Worksheet\+Names}{list\+Worksheet\+Names}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md667}
The {\ttfamily list\+Worksheet\+Names()} method returns a simple array listing each worksheet name within the workbook\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$reader\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::createReader(\$inputFileType);}
\DoxyCodeLine{}
\DoxyCodeLine{\$worksheetNames\ =\ \$reader-\/>listWorksheetNames(\$inputFileName);}
\DoxyCodeLine{}
\DoxyCodeLine{echo\ '<h3>Worksheet\ Names</h3>';}
\DoxyCodeLine{echo\ '<ol>';}
\DoxyCodeLine{foreach\ (\$worksheetNames\ as\ \$worksheetName)\ \{}
\DoxyCodeLine{\ \ \ \ echo\ '<li>',\ \$worksheetName,\ '</li>';}
\DoxyCodeLine{\}}
\DoxyCodeLine{echo\ '</ol>';}

\end{DoxyCode}


See {\ttfamily \doxylink{18___reading__list__of__worksheets__without__loading__entire__file_8php}{samples/\+Reader/18\+\_\+\+Reading\+\_\+list\+\_\+of\+\_\+worksheets\+\_\+without\+\_\+loading\+\_\+entire\+\_\+file.\+php}} for a working example of this code.\hypertarget{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md668}{}\doxysubsection{\texorpdfstring{list\+Worksheet\+Info}{list\+Worksheet\+Info}}\label{md__c_1_2_users_2gallo_2_one_drive_2_documents_2_s_a_x_c3_x_a9-casali_2www_2wp-content_2plugins_435f04114bf80d293b60802d71ec916c_autotoc_md668}
The {\ttfamily list\+Worksheet\+Info()} method returns a nested array, with each entry listing the name and dimensions for a worksheet\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ php}
\DoxyCodeLine{\$reader\ =\ \(\backslash\)PhpOffice\(\backslash\)PhpSpreadsheet\(\backslash\)IOFactory::createReader(\$inputFileType);}
\DoxyCodeLine{}
\DoxyCodeLine{\$worksheetData\ =\ \$reader-\/>listWorksheetInfo(\$inputFileName);}
\DoxyCodeLine{}
\DoxyCodeLine{echo\ '<h3>Worksheet\ Information</h3>';}
\DoxyCodeLine{echo\ '<ol>';}
\DoxyCodeLine{foreach\ (\$worksheetData\ as\ \$worksheet)\ \{}
\DoxyCodeLine{\ \ \ \ echo\ '<li>',\ \$worksheet['worksheetName'],\ '<br\ />';}
\DoxyCodeLine{\ \ \ \ echo\ 'Rows:\ ',\ \$worksheet['totalRows'],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ '\ Columns:\ ',\ \$worksheet['totalColumns'],\ '<br\ />';}
\DoxyCodeLine{\ \ \ \ echo\ 'Cell\ Range:\ A1:',}
\DoxyCodeLine{\ \ \ \ \$worksheet['lastColumnLetter'],\ \$worksheet['totalRows'];}
\DoxyCodeLine{\ \ \ \ echo\ '</li>';}
\DoxyCodeLine{\}}
\DoxyCodeLine{echo\ '</ol>';}

\end{DoxyCode}


See {\ttfamily \doxylink{19___reading__worksheet__information__without__loading__entire__file_8php}{samples/\+Reader/19\+\_\+\+Reading\+\_\+worksheet\+\_\+information\+\_\+without\+\_\+loading\+\_\+entire\+\_\+file.\+php}} for a working example of this code. 